Application Design Tips
=

정규화와 반정규화는 절대적인 우위의 관계가 아니다.
-
   
속도를 향상시키기 위해서는 임베드하여 데이터 중복을 허용하는 것이 좋다.
정합성을 유지하기 위해서는 레퍼런스를 사용하는 것이 좋다.

선택의 판단 요소
1. 읽기가 빈번하고 변경이 적은지?
2. 정합성이 어느정도로 중요한지? 여러 도큐먼트가 동시에 수정되는 경우가 있는지? 또 이런 경우 수많은 도큐먼트 사이의 신뢰할 수 있는 정보의 출처를 규정할 수 있는지?
3. 읽기의 속도가 중요한지?


예측할 수 없는 미래를 대비할 수 있는 구조를 원한다면 정규화가 좋다
-
오랜 시간 사용해야 하거나 여러 어플리케이션을 아울러 사용해야하는 데이터의 경우에는 정규화를 하는 것이 좋다. 미래는 예측할 수 없고 질의의 방식이 변할 수도 있다.

데이터를 단일 쿼리로 가져오기 위해 노력해야 한다.
-
어플리케이션의 유닛은 백앤드에 들어오는 요청을 생각할 수 있다.
몽고에서 스키마는 이 어플리케이션 유닛을 단위로 설계해야 한다. 단, 당연하게도 단일 쿼리라는 것이 단일 도큐먼트를 의미하지는 않는다. 어플리케이션이 커진다면 완벽하게 준수하기 어렵겠지만, 최초의 설계를 판단하는 기준 중의 하나가 될 수는 있다.

특정 시점의 스냅샷을 뜨고 싶은 데이터라면 임베드하는 것이 좋다.
-

제한 없이 커질 수 있는 필드는 임베드하지 않는 것이 좋다.
-
몽고에서 어레이에 데이터를 지속적으로 추가하는 경우 비효율적이 존재한다. 따라서 일정한 크기의 데이터를 가지도록 하는 것이 좋다.

필드에 대해 어느정도 예측이 가능하다면, 도큐먼트의 생성시점에 추가하는 것이 좋다.
-
만일 미래의 특정 시점에 특정 필드가 추가될 것이란 사실을 안다면, 도큐먼트의 생성시점에 필드를 미리 생성해주는 것이 효율적이다.
단순히 존재하는 필드의 업데이트를 해주는 것은 새로운 필드를 추가할 수 있는 공간이 있는지 확인하는 과정을 생략할 수 있기 때문에 성능적인 이득이 있다.

만약 도큐먼트가 어느정도 크기까지 커질 지 감을 잡을 수 있다면, 공간을 미리 할당하는 것이 좋다.
-
예를 들면 생성시점에 가비지 필드를 생성해 사용할 만큼의 크기를 할당해준뒤, 즉시 unset하는 방법을 생각할 수 있다.

이렇게 한다면, 몽고에서 도큐먼트를 생성해줄 때, 충분한 룸이 있는 곳에 위치시켜준다.

질의에 적합하지 않은 데이터는 어레이에 담는 것이 좋다
-
서브 도큐먼트는 질의할 요소가 무엇인지를 명확하게 알 때 쓰는 것이 좋다. 만약 서브도큐먼트의 키가 특정할 수 없다면, 이것을 질의할 방법이 없다.
그런 경우에는 않다면 그냥 어레이에 담아라.

bad practice:
```
{
"_id" : "fred",
"items" : { 
    "slingshot" : {
        "type" : "weapon", 
        "damage" : 23, 
        "ranged" : true
        },
        "jar" : {
            "type" : "container",
            "contains" : "fairy" 
        },
        "sword" : {
            "type" : "weapon",
            "damage" : 50,
            "ranged" : false 
        }
    }
}
```

better practice:

```
{
"_id" : "fred",
"items" : [ 
    {
        "id" : "slingshot", 
        "type" : "weapon", 
        "damage" : 23, 
        "ranged" : true
    }
]
}
```

자급자족이 가능한 도큐먼트를 설계하라
-
몽고는 데이터의 처리가 거의 없는, 단순한 저장과 반환을 위한 데이터 배이스이다. 평균을 구하는 등의 연산은 몽고에서 수행하기에 적합하지 않다.
js를 사용해 연산을 처리하는 과정은 상당한 성능적인 패널티를 유발한다.

띠라서 이런 목적에 알맞게, 클라이언트 단에서 처리할 수 있는 연산은 클라이언트 단에서 처리하는 것이 좋다. 이게 싫다면, 암시적이게 작성되어 연산이 필요한 데이터에 명시적인 필드를 추가하는 방법도 있다. (단, 이 방법은 nosql의 특징상, 필드에 대해 클라이언트 단에서 확신할 수 없기 때문에 크로스체크가 필요하다. 굳이 이럴 필요가 있나 싶다.)

$연산이 js보다 좋다.
-
일반적으로 잘 설계된 도큐먼트는 굳이 복잡한 연산이 필요없다.
하지만 필요하다면 js 코드를 사용할 수도 있다. 하지만 느리다.
왜냐하면 일반적인 연산자를 사용할 때는 몽고는 내부적으로 BSON 데이터로 변환하여 전송한다.
몽고의 데이터는 BSON의 형태를 하고 있기 때문에 비교가 빠르다.
js를 사용하게 되면 모든 도큐먼트를 js 객체로 변환하여, js 코드를 실행시킨다.
그리고 이후에 다시 원복시키는 과정을 수행해야 하니 당연히 느리다.

데이터 정합성 이슈를 처리하기 위해 코드를 작성하라
-
몽고의 스키마가 없는, 반정규화된 특징에도 불구하고 정합성을 지켜야 할 수가 있다.
하지만 몽고에는 정합성을 보장하지 못하는 다양한 상황이 존재하므로 이에 대비하는 것이 좋다.
