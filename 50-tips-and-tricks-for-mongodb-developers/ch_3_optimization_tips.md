Optimization Tips
=

디스크 엑세스를 최소화하라
-
RAM에서 데이터를 얻는 것은 빠르지만, 디스크에 다녀오는 것은 수 백만배 많은 비용이 든다.
대부분의 최적화는 결국 디스크에 다녀오는 시간을 줄이는 것으로 시작한다.

1. SSD를 사용하기: 
2. RAM을 더 많이 추가하기

두 방식 모두 물론 한계가 있다.
하지만 꼭 두 방식이 아니라도, 접근할 수 있는 데이터는 일정한 경향을 보이는 경우가 많으므로 디스크에 있는 데이터 중 일부를 메모리에 유지하는 방식으로 데이터를 최적화 할 수 있는 방법은 반드시 있다.

메모리를 효울적으로 쓰기 위해 인덱스를 사용하라
-
몽고에서 데이터를 쿼리하는 방식은 대략 다음과 같다.
1. 도큐먼트의 첫 페이지를 메모리에 로드한다.
2. 데이터가 매칭되는지 찾는다
3. 매칭되는 데이터가 없다면 다음 페이지를 메모리에 로드한다.
4. 배치에 원하는 데이터가 모두 차면 클라이언트에 보내준다.

이런 식이라면 모든 도큐먼트를 살펴보는 것 말고는 방법이 없다.

그러니 인덱스를 사용하자. 인덱스는 단순히 빠를 뿐 아니라, 일반적으로 포인터를 가지고 있기 때문에 일반적인 도큐먼트보다 용량이 훨씬 적다.

인덱스를 항상 쓰지는 마라
-
인덱스는 유용하지만, 모든 곳에 써도 되는 것은 아니다.
몽고에서 효율이 떨어지기 시작하는 구간은 전체의 50%이하의 데이터이다.
카디널리티와 스윗 스팟에 관한 내용, 하고자 하는 말은 RDB와 크게 다르지 않다.

covered index query를 사용해라
-
만약 특정 필드만이 필요하고, 그 필드를 인덱스에서 처리할 수 있다면  covered index query를 사용하는 것이 좋다.
covered index는 단순 포인터를 들고 있는 것이 아니라 실제 값을 가지고 있다. 이를 사용하면 디스크에 접근하는 대신, 메모리에 올라 있는 값을 바로 클라이언트 단에 리턴할 수 있다는 장점이 있다.

멀티 쿼리 성능을 향상시키기 위해서 컴파운드 인덱스를 사용하라
-
멀티 쿼리를 해야하는 경우 가능하면 컴파운드를 거는 것이 좋다. (항상 가능하지는 않을 수 있지만, 가능하다면)

빠른 스캔을 위해서는 계층화된 도큐먼트를 만들어라
-
적절한 계층화가 이루어지면 몽고에서 스캔을 할 때 트리 구조를 사용할 수가 있다.
이렇게 되면 모든 필드를 풀스캔 하는 대신, 필요한 필드만 스캔할 수 있기 때문에 성능적으로 약간의 최적화를 기대할 수 있다.

ㄴ> 신기방기

AND 조건절을 사용할 때는, 필터링 결과가 작고 빠른 조건을 앞에 사용하라
-
가, 나, 다 세 조건이 있다고 가정하자.

가는 1000000000000......0000개
나는 100 개
다는 1개가 매칭된다고 가정하자.

'가 AND 나 AND 다'와 같은 방식으로 사용하면 가부터 match 쿼리가 사용되게 된다. 이때, 가 데이터 영역은 공유되는 영역이므로 나를 조사할 때도 순차적으로 사용된다. 필터링하는 것이 큰 영역을 가지게 되는 경우 비효율적이다.

반면에 '다 AND 나 AND 가'방식으로 사용한다면 공유되는 영역이 작아진다. 효과를 볼 수 있다.

OR 조건절을 사용할 때에는, 가장 포괄적으로 사용 될 수 있는 조건을 앞에 세워라.
- 
AND 조건절과 정확히 반대되는 이유를 생각하면 된다.
(OR은 첫번째 확인한 데이터가 해당하지 않는 영역을 다음 조건 조회의 대상으로 삼을 것이기 때문)
