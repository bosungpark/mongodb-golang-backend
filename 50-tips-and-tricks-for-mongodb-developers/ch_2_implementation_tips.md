Implementation Tips
=

올바른 타입을 사용하라
-
타입은 질의와 정렬, 저장시 바이트 할당 등에 영향을 미치는 요소이다.

- Numbers: 32/64비트 정수, float 등 어떤 자료형이라도 number로 취급된다. 몽고는 오버플로우가 생길 경우, 내부적으로 32비트 정수를 64비트로 변환하여 사용한다. 하지만 bit(AND, OR)연산과 같이 일부 케이스는 정수만 사용 가능하다. 
- Dates: date형식을 사용하며, 때로는 ISO-format을 사용하기도 한다.
- Strings: UTF-8로 인코딩되거나 바이너리 형식으로 저장된다.
- ObjectIds: queryability, ObjectId에서 도큐먼트의 생성일시를 추론할 수 있다는 특징, 메모리상으로 문자열보다 2배 정도의 효율을 가진다는 특징 때문에 문자열과 구분되는 ObjectIds를 별도의 타입으로 가진다.

만약 자신만의 단순하고 유니크한 id가 있다면 _id를 오버라이드 하라
-
만약 단순하게 유니크한 id를 사용할 수 있다면 저장공간을 약간 줄여주는 효과가 있다. 특히 인덱스를 id에 거는 경우에는 전체 인덱스의 자원과 저장공간을 조금씩 줄여주는데 모아서 계산하면 절약할 수 있는 공간이 제법 된다.

하지만 고려해야할 점이 있다. 유니크에 대한 보장은 당연히 고려해야 한다.
뿐만 아니라 인덱스 트리의 구조도 생각할 필요가 있다.

ObjectId는 증가하는 특징을 가진다. 따라서 몽고는 B-tree 오른쪽 끝 부분만을 신경쓰면 된다. 하지만 만약 커스텀한 아이디가 랜덤하게 할당된다면, 몽고는 인덱스의 페이지를 메모리에 가져와 일부를 업데이트 하는 비효율을 감수하게 된다.

도큐먼트를 _id로 설정하는 것을 피해라
-
,,,이건 상식적으로,,되는지도 몰랐음,,,

당연히 인덱싱이나, 쿼리시에도 구린 부분이 있을테니 피하는게 좋을듯
또 아이디는 불변해야하는데, 이건 상식적으로 아닌듯

데이터베이스 레퍼런스를 사용하지 마라
-
데이터베이스 레퍼런스는 다음과 같은 형태를 가진 서브 도큐먼트이다.
{ \$id : identifier, $ref : collectionName}

하지만 이것이 몽고에서 조인을 하는 방식이라고 착각해서는 안된다.
이건 그냥 컬렉션의 이름과 아이디만을 들고 있는 서브 도큐먼트이다.
이는 즉, 디레퍼런싱을 하기 위해서는 쿼리가 2번 발생한다는 의미이다.

일반적으로 어떤 컬렉션과 관계를 가질지 명확히 아는 경우라면 단순히 _id를 저장하는 것만으로 충분하며, 데이터베이스 레퍼런스는 낭비이다.

GridFS를 작은 바이너리 데이터에 사용하지 마라
-
GridFS는 파일의 메타데이터와 콘텐츠 두 가지를 패치한다.
그래서 GridFS를 작은 바이너리 파일에 사용한다면 어플리케이션이 하는 쿼리의 수를 2배로 만드는 것이다. GridFS는 한 도큐먼트에는 쓰기 함든 큰 바이너리 데이터를 쪼개 몽고에 넣는 것이 목적이다. 클라이언트에 한 번에 로드하기 힘들고 스트리밍을 할 필요가 있는 데이터는 적합한 후보가 될 수 있다.

“seamless” failover를 관리하라
-
몽고는 “seamless” failover를 한다. 즉, 문제가 발생하면 서비스에 인터럽트 하지 않고 회복을 시도한다. 하지만 몇몇 에러는 원활한 처리가 어렵다.

이런 선택이 필요한 몇몇 케이스(네트워크 문제 시, 재시도를 한 것인가에 대한 대응 등)의 경우 추가 처리가 필요하다.

레플리카 셋에서 발생하는 문제에 대해 대응할 수 있어야 한다.
-







